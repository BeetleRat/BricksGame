\subsubsection*{EventMessageListener.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// <para>A class that triggers events associated with a biofeedback device.</para>
/// </summary>
public sealed class EventMessageListener : MonoBehaviour
{
    /// <summary>
    /// <para>Event triggered when the connection status of the device changes.</para>
    /// </summary>
    public event UnityAction<bool> ConnectionChanged;

    /// <summary>
    /// <para>Event triggered when a message is arrived from the device.</para>
    /// </summary>
    public event UnityAction<string> MessageArrived;


    private const string MESSAGE_ARRIVED_PREFIX = "Message arrived: ";

    // Invoked when a line of data is received from the serial device.
    private void OnMessageArrived(string msg)
    {
        CustomLogger.Log(this, MESSAGE_ARRIVED_PREFIX + msg);
        MessageArrived?.Invoke(msg);
    }

    // Invoked when a connect/disconnect event occurs. The parameter 'success'
    // will be 'true' upon connection, and 'false' upon disconnection or
    // failure to connect.
    private void OnConnectionEvent(bool success)
    {
        ConnectionChanged?.Invoke(success);
    }
}
\end{minted}
\subsubsection*{PulseReceiver.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// <para>A component that requests, receives and processes the pulse from a biofeedback device.</para>
/// If a biofeedback device is not available, this component may use placeholder
/// </summary>
[RequireComponent(typeof(EventMessageListener))]
public sealed class PulseReceiver : MonoBehaviour
{
    /// <summary>
    /// <para>Event triggered when a heart rate value is received from a device or placeholder.</para>
    /// </summary>
    public event UnityAction<int> PulseReceived;

    /// <summary>
    /// <para>Event triggered when heart rate acceleration is recalculated.</para>
    /// </summary>
    public event UnityAction<float> AccelerationCalculated;

    private const string PULSE_PREFIX = "pulse=";
    private const string PULSE_REQUEST_MESSAGE = "1";
    private const int PULSE_NOT_RECEIVED = -1;

    [Tooltip("Whether to write debug information to the console")] 
    [SerializeField] private bool _debug = false;

    [SerializeField] private SerialController _serialController;

    [Tooltip("If the device returns an erroneous value, you can use this parameter to correct the result")]
    [SerializeField] private int _receivedPulseOffset;

    [Tooltip("Frequency of requesting a heart rate value from the device")] 
    [Min(0.000001f)] 
    [SerializeField] private float _pollingRateSeconds;

    [Tooltip("Device polling period for which heart rate acceleration will be recalculated")] 
    [Min(1)] 
    [SerializeField] private int _recalculatingCyclePeriod;

    [SerializeField] private bool _usePlaceholder;
    [Range(1, 150)] 
    [SerializeField] private int _placeholderPulse;
    [SerializeField] private float _placeholderAcceleration;

    private bool connected = false;
    private float timeSinceLastPolling = 0;
    private EventMessageListener eventMessageListener;
    private int currentRecalculatingCycle;
    private int firstPeriodPulse;
    private int lastPeriodPulse;

    private void Start()
    {
        eventMessageListener = GetComponent<EventMessageListener>();
        currentRecalculatingCycle = 0;
        firstPeriodPulse = 0;
        eventMessageListener.MessageArrived += GetMessageFromSerial;
        eventMessageListener.ConnectionChanged += SetConnectionWithSerial;
    }

    private void FixedUpdate()
    {
        timeSinceLastPolling += Time.deltaTime;
        if (timeSinceLastPolling > _pollingRateSeconds)
        {
            if (_usePlaceholder)
            {
                GetBiofeedbackFromPlaceholder();
            }
            else
            {
                SendMessageToSerialController();
            }

            timeSinceLastPolling = 0;
        }
    }

    private void OnDestroy()
    {
        if (eventMessageListener != null)
        {
            eventMessageListener.MessageArrived -= GetMessageFromSerial;
            eventMessageListener.ConnectionChanged -= SetConnectionWithSerial;
        }
    }

    private void SetConnectionWithSerial(bool isConnected)
    {
        connected = isConnected;

        if (connected)
        {
            DebugLog("Connection established");
            SendMessageToSerialController();
        }
        else
        {
            DebugLog("Connection attempt failed or disconnection detected");
        }
    }

    private void GetMessageFromSerial(string msg)
    {
        string messageFromBiofeedback = msg;
        DebugLog("Serial controller returned message: " + messageFromBiofeedback);

        int pulseNumber = GetPulseFromMessage(messageFromBiofeedback);
        CalculateAcceleration(pulseNumber);
    }

    private void GetBiofeedbackFromPlaceholder()
    {
        string pulseMessage = PULSE_PREFIX + _placeholderPulse;

        int pulseNumber = GetPulseFromMessage(pulseMessage);
        CreatePlaceholderAcceleration(_placeholderAcceleration);
    }


    private void SendMessageToSerialController()
    {
        if (!connected)
        {
            PulseReceived?.Invoke(PULSE_NOT_RECEIVED);
            DebugErr($"Failed to retrieve data from the device. The device is not responding. The heart rate value is set to {PULSE_NOT_RECEIVED.ToString()}");
        }

        _serialController.SendSerialMessage(PULSE_REQUEST_MESSAGE);
        DebugLog("Send message to serial controller: " + PULSE_REQUEST_MESSAGE);
    }

    private int GetPulseFromMessage(string messageFromBiofeedback)
    {
        if (messageFromBiofeedback != null && messageFromBiofeedback.Contains(PULSE_PREFIX))
        {
            string pulseNumberAsString = messageFromBiofeedback.Replace(PULSE_PREFIX, "");
            int receivedPulseNumber = int.Parse(pulseNumberAsString) + _receivedPulseOffset;
            PulseReceived?.Invoke(receivedPulseNumber);
            return receivedPulseNumber;
        }

        return 0;
    }

    private void CalculateAcceleration(int pulse)
    {
        // TODO Уточнить формулу получения ускорения пульса
        float acceleration = 0.0f;
        currentRecalculatingCycle++;
        if (currentRecalculatingCycle >= _recalculatingCyclePeriod)
        {
            currentRecalculatingCycle = 0;
            int pulseRange = pulse - firstPeriodPulse;
            acceleration = pulseRange / (_pollingRateSeconds * _recalculatingCyclePeriod);
            DebugLog($"Acceleration was recalculated: {acceleration} = {pulseRange.ToString()}/({_pollingRateSeconds.ToString()}*{_recalculatingCyclePeriod.ToString()})");

            AccelerationCalculated?.Invoke(acceleration);
            firstPeriodPulse = pulse;
        }
    }

    private void CreatePlaceholderAcceleration(float acceleration)
    {
        currentRecalculatingCycle++;
        if (currentRecalculatingCycle >= _recalculatingCyclePeriod)
        {
            currentRecalculatingCycle = 0;
            AccelerationCalculated?.Invoke(acceleration);
        }
    }

    private void DebugLog(string message)
    {
        if (_debug)
        {
            CustomLogger.Log(this, message);
        }
    }

    private void DebugErr(string message)
    {
        if (_debug)
        {
            CustomLogger.Error(this, message);
        }
    }
}
\end{minted}
\subsubsection*{AbstractProjectile.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>
/// Abstract class of an object moving from the spawn point to the point of its destruction.
/// The projectile performs an action implemented in the implementation
/// when it comes in contact with <see cref="PlayerBodypart"/>.
/// </para>
/// </summary>
[RequireComponent(typeof(Rigidbody))]
public abstract class AbstractProjectile : MonoBehaviour
{
    /// <summary>
    /// <para><see cref="LevelManager"/> reference.</para>
    /// </summary>
    protected LevelManager levelManager;

    private Vector3 destroyPosition;
    private float movementSpeed = 6f;
    private ProjectileSpawner projectileSpawner;

    private bool isBrickMove;

    /// <summary>
    /// <para>Sets level manager reference.</para>
    /// </summary>
    /// <value>The level manager reference</value>
    public LevelManager LevelManager
    {
        set => levelManager = value;
    }

    /// <summary>
    /// <para>Sets projectile spawner.</para>
    /// </summary>
    /// <value>The projectile spawner</value>
    public ProjectileSpawner ProjectileSpawner
    {
        set => projectileSpawner = value;
    }

    /// <summary>
    /// <para>Sets projectile movement speed.</para>
    /// </summary>
    /// <value>The projectile movement speed</value>
    public float MovementSpeed
    {
        set => movementSpeed = value;
    }

    /// <summary>
    /// <para>Sets position of projectile destruction.</para>
    /// </summary>
    /// <value>The position of projectile destruction</value>
    public Vector3 DestroyPosition
    {
        set => destroyPosition = value;
    }

    private void Start()
    {
        isBrickMove = true;
    }

    private void FixedUpdate()
    {
        if (isBrickMove)
        {
            Move();
        }

        CheckDestination();
    }

    private void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.TryGetComponent(out PlayerBodypart player) && isBrickMove)
        {
            isBrickMove = false;
            PerformAction();
        }
    }

    private void OnDestroy()
    {
        projectileSpawner.RemoveProjectileFromSpawnedList(this);
    }

    private void Move()
    {
        transform.position = Vector3.MoveTowards(transform.position, destroyPosition, movementSpeed);
    }

    private void CheckDestination()
    {
        if (transform.position == destroyPosition)
        {
            Destroy(gameObject);
        }
    }

    /// <summary>
    /// <para>The action that will be performed when a projectile comes into contact with <see cref="PlayerBodypart"/>.</para>
    /// </summary>
    protected abstract void PerformAction();
}
\end{minted}
\subsubsection*{DamageBrick.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>
/// A <see cref="AbstractProjectile">projectile</see> that looks like a brick.
/// If it comes in contact with player, it will take away part of his health points.
/// </para>
/// </summary>
public sealed class DamageBrick : AbstractProjectile
{
    [Tooltip("The amount of health that will be taken away from the player when the projectile comes into contact with the players bodypart")]
    [Range(0, 100)]
    [SerializeField] private int _hpDrain = 1;
    
    [Header("Blast settings")]
    [SerializeField] private float _crashForce = 6f;
    [SerializeField] private float _crashRadius = 6f;
    [SerializeField] private float _destructionTimeSec = 2.5f;

    /// <summary>
    /// <inheritdoc cref="AbstractProjectile.PerformAction"/>
    /// </summary>
    protected override void PerformAction()
    {
        levelManager?.DrainHealthPoint(_hpDrain);
        Crash(_crashForce, _crashRadius);
    }

    private void Crash(float force, float radius)
    {
        if (TryGetComponent(out Rigidbody rigidbody))
        {
            // Вернуть объекту возможность физического взаимодействия
            rigidbody.isKinematic = false;
            rigidbody.useGravity = true;
            // Растолкать объект в разные стороны
            rigidbody.AddExplosionForce(force,
                transform.position + new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f), Random.Range(-1f, 1f)), radius);
        }

        Destroy(gameObject, _destructionTimeSec);
    }
}
\end{minted}
\subsubsection*{HealingBrick.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using DG.Tweening;
using UnityEngine;

/// <summary>
/// <para>
/// A <see cref="AbstractProjectile">projectile</see> that looks like a brick.
/// If it comes in contact with player, it will give them health points.
/// </para>
/// </summary>
public sealed class HealingBrick : AbstractProjectile
{
    [Tooltip("The amount of health that will be given to the player when the projectile comes into contact with the players bodypart")]
    [Range(0, 100)]
    [SerializeField] private int _hpAdded = 1;

    [Header("Fade out settings")]
    [SerializeField] private float _transformMultiplier;
    [SerializeField] private float _magnificationSpeed;
    [SerializeField] private float _fadeOutSpeed;

    private bool isFadeOut;

    /// <summary>
    /// <inheritdoc cref="AbstractProjectile.PerformAction"/>
    /// </summary>
    protected override void PerformAction()
    {
        levelManager?.AddHealthPoint(_hpAdded);
        FadeOut();
    }

    private void FadeOut()
    {
        transform.DOScale(transform.localScale * _transformMultiplier, _magnificationSpeed)
            .OnComplete(() => transform.DOScale(0, _fadeOutSpeed));
    }
}
\end{minted}
\subsubsection*{ProjectileSpawner.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System;
using System.Collections.Generic;
using UnityEngine;
using Random = UnityEngine.Random;

/// <summary>
/// <para>Specific spawn speed settings for a particular game speed state.</para>
/// </summary>
[Serializable]
sealed class SpawnerSpeed
{
    public Speed ForSpeed;
    public float MovementSpeed;
    [Range(1, 300)] 
    public float SpawnSpeed;
}

/// <summary>
/// <para>Spawned projectile info.</para>
/// </summary>
[Serializable]
sealed class SpawnedProjectile
{
    public AbstractProjectile SpawnedObject;
    [Range(0, 100)] 
    public int SpawnChance;
    public ObjectMovement[] MovementPoints;
}

/// <summary>
/// <para>The component that performs projectile spawning.</para>
/// It is a <see cref="AbstractSpeedChangingComponent"/>
/// </summary>
public sealed class ProjectileSpawner : AbstractSpeedChangingComponent
{
    private const float SPEED_DIVIDER = 70;

    [SerializeField] private LevelManager _levelManager;
    [SerializeField] private SpawnedProjectile[] _projectiles;

    [SerializeField] private List<SpawnerSpeed> _speedSettings;

    private SpawnerSpeed currentSpeed;
    private bool isSpawnerActive = false;
    private float timeAfterSpawn;
    private List<AbstractProjectile> spawnedProjectiles;

    private void Awake()
    {
        spawnedProjectiles = new List<AbstractProjectile>();
        ValidateSettings(ref _speedSettings);
    }

    private void Start()
    {
        if (_speedSettings.Count == 0)
        {
            CustomLogger.Error(this, "Speed Settings List is empty");
        }
        else
        {
            currentSpeed = _speedSettings[0];
        }

        _levelManager.GameStarted += StartSpawn;
        _levelManager.GameEnded += StopSpawnAndDestroyAllObjects;
        timeAfterSpawn = 200;
    }

    private void Update()
    {
        if (isSpawnerActive)
        {
            PreformSpawn();
        }
    }

    private void OnDestroy()
    {
        _levelManager.GameStarted -= StartSpawn;
        _levelManager.GameEnded -= StopSpawnAndDestroyAllObjects;
    }

    /// <summary>
    /// <para>Remove the specified projectile from the list of tracked projectiles.</para>
    /// </summary>
    /// <param name="abstractProjectile">Removed projectile</param>
    public void RemoveProjectileFromSpawnedList(AbstractProjectile abstractProjectile)
    {
        spawnedProjectiles.Remove(abstractProjectile);
    }

    private void ValidateSettings(ref List<SpawnerSpeed> speedSettings)
    {
        speedSettings.Sort((ss1, ss2) => ss1.ForSpeed - ss2.ForSpeed);
        RemoveDuplicatesFrom(ref speedSettings);
    }

    private void RemoveDuplicatesFrom(ref List<SpawnerSpeed> list)
    {
        for (int i = list.Count - 1; i > 0; i--)
        {
            if (list[i].ForSpeed == list[i - 1].ForSpeed)
            {
                list.Remove(list[i]);
            }
        }
    }

    private void StartSpawn()
    {
        isSpawnerActive = true;
    }

    private void StopSpawnAndDestroyAllObjects()
    {
        isSpawnerActive = false;
        for (int i = spawnedProjectiles.Count - 1; i >= 0; i--)
        {
            Destroy(spawnedProjectiles[i].gameObject);
        }
    }

    private void PreformSpawn()
    {
        timeAfterSpawn += Time.deltaTime;
        if (timeAfterSpawn >= (100 / currentSpeed.SpawnSpeed))
        {
            SpawnRandomProjectile();
            timeAfterSpawn = 0;
        }
    }

    private void SpawnRandomProjectile()
    {
        int totalNumbers = 0;

        foreach (SpawnedProjectile brick in _projectiles)
        {
            totalNumbers += brick.SpawnChance;
        }

        int winner = Random.Range(1, totalNumbers);
        foreach (SpawnedProjectile brick in _projectiles)
        {
            totalNumbers -= brick.SpawnChance;
            if (winner >= totalNumbers)
            {
                SpawnProjectile(brick);
                break;
            }
        }
    }

    private void SpawnProjectile(SpawnedProjectile projectile)
    {
        ObjectMovement brickMovement = projectile.MovementPoints[Random.Range(0, projectile.MovementPoints.Length)];

        Transform spawnPoint = brickMovement.StartPoint;
        Vector3 spawnedProjectilePosition = projectile.SpawnedObject.transform.position;

        Vector3 spawnPosition = spawnPoint.position + spawnedProjectilePosition;
        Quaternion spawnRotation = spawnPoint.rotation * projectile.SpawnedObject.transform.rotation;
        Vector3 destroyPosition = brickMovement.EndPoint.position + spawnedProjectilePosition;

        AbstractProjectile spawnProjectile = Instantiate(projectile.SpawnedObject, spawnPosition, spawnRotation);

        spawnProjectile.MovementSpeed = currentSpeed.MovementSpeed / SPEED_DIVIDER;
        spawnProjectile.DestroyPosition = destroyPosition;
        spawnProjectile.LevelManager = _levelManager;
        spawnProjectile.ProjectileSpawner = this;

        spawnedProjectiles.Add(spawnProjectile);
    }

    /// <summary>
    /// <inheritdoc cref="AbstractSpeedChangingComponent.ChangeSpeed"/>
    /// </summary>
    /// <param name="speed"><inheritdoc cref="AbstractSpeedChangingComponent.ChangeSpeed"/></param>
    public override void ChangeSpeed(Speed speed)
    {
        if (speed == Speed.STOP)
        {
            isSpawnerActive = false;
            return;
        }

        if (_speedSettings.Count == 0)
        {
            CustomLogger.Error(this, "Speed Settings List is empty");
            return;
        }

        foreach (SpawnerSpeed spawnerSpeed in _speedSettings)
        {
            if (spawnerSpeed.ForSpeed == speed)
            {
                currentSpeed = spawnerSpeed;
                return;
            }
        }

        LogNoSpeedSettingsFor(speed);
    }
}
\end{minted}
\subsubsection*{ScoreBrick.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using DG.Tweening;
using UnityEngine;

/// <summary>
/// <para>
/// A <see cref="AbstractProjectile">projectile</see> that looks like a brick.
/// If it comes in contact with player, it will increase the player's score.
/// </para>
/// </summary>
public sealed class ScoreBrick : AbstractProjectile
{
    [Tooltip("The number of points a player will get")]
    [Range(1, 100)]
    [SerializeField] private int _scorePoints;

    [Header("Fade out settings")]
    [SerializeField] private float _transformMultiplier;
    [SerializeField] private float _fadeOutSpeed;

    private bool isFadeOut;
    private int activeRenderersCount;

    /// <summary>
    /// <inheritdoc cref="AbstractProjectile.PerformAction"/>
    /// </summary>
    protected override void PerformAction()
    {
        levelManager.AddScore(_scorePoints);
        FadeOut();
    }

    private void FadeOut()
    {
        transform.DOScale(transform.localScale * _transformMultiplier, _fadeOutSpeed);

        var renderers = GetComponentsInChildren<Renderer>();
        if (renderers.Length > 0)
        {
            activeRenderersCount = renderers.Length;
            foreach (var renderer in renderers)
            {
                renderer.material.DOFade(0f, _fadeOutSpeed)
                    .OnComplete(TryToDestroyObject);
            }
        }
    }

    private void TryToDestroyObject()
    {
        activeRenderersCount--;
        if (activeRenderersCount <= 0)
        {
            Destroy(gameObject);
        }
    }
}
\end{minted}
\subsubsection*{AbstractBiofeedbackManager.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// <para>Enumeration of heart rate states returned by biofeedback.</para>
/// </summary>
[Serializable]
public enum PulseCondition
{
    SLOW,
    NORMAL,
    FAST,
    CRITICAL
}

/// <summary>
/// <para>Structure correlating the numerical value of the biofeedback indicator, heart rate state and color of the debug bar.</para>
/// </summary>
[Serializable]
public class PulseRateCondition
{
    [Tooltip("If pulse rate lower then selected, then set selected condition")]
    public float Rate;

    public PulseCondition Condition;
    public Color UIBarColor;
}

/// <summary>
/// <para> Abstract biofeedback manager class.</para>
/// It provides his subclass PulseConditionChange action that they must call to interact with game managers.
/// It also provides a list of <see cref="PulseRateCondition"/> and debug bar as script parameters.
/// And it provides <see cref="PulseReceiver"/> component and <see cref="PulseCondition"/> variable for biofeedback interaction.
/// </summary>
[RequireComponent(typeof(PulseReceiver))]
public abstract class AbstractBiofeedbackManager : MonoBehaviour
{
    /// <summary>
    /// <para>Action triggered when <see cref="PulseCondition"/> change.</para>
    /// </summary>
    public abstract event UnityAction<PulseCondition> PulseConditionChange;

    /// <summary>
    /// <para>List of <see cref="PulseRateCondition"/> used to determine heart rate status.</para>
    /// </summary>
    [SerializeField] protected List<PulseRateCondition> _pulseRateConditions;

    /// <summary>
    /// <para><see cref="UINumberParameterBar"/> used to display the current parameter value on UI in debug mode.</para>
    /// </summary>
    [SerializeField] protected UINumberParameterBar _debugUiBar;

    [SerializeField] private bool _showDebugUiBar;

    [Header("[Optional]")] 
    [SerializeField] private string _uiBarParameterName;

    /// <summary>
    /// <para><see cref="PulseReceiver"/> component.</para>
    /// </summary>
    protected PulseReceiver pulseReceiver;

    /// <summary>
    /// <para>The <see cref="BiofeedbackControlType"/></para>
    /// </summary>
    protected BiofeedbackControlType _pulseControl;

    /// <summary>
    /// <para>Current <see cref="PulseCondition"/> state.</para>
    /// </summary>
    protected PulseCondition pulseCondition = PulseCondition.NORMAL;

    /// <summary>
    /// <para>The <see cref="BiofeedbackControlType"/></para>
    /// </summary>
    public BiofeedbackControlType PulseControl => _pulseControl;

    /// <summary>
    /// <para>Current <see cref="PulseCondition"/> state.</para>
    /// </summary>
    public PulseCondition PulseCondition => pulseCondition;

    private void Start()
    {
        OnStart();
    }

    protected virtual void OnStart()
    {
        pulseReceiver = GetComponent<PulseReceiver>();
        ValidateConditionsList();
        _debugUiBar?.SetVisible(_showDebugUiBar);
        if (_uiBarParameterName.Length > 0)
        {
            _debugUiBar?.SetParameterName(_uiBarParameterName);
        }
    }

    private void ValidateConditionsList()
    {
        if (_pulseRateConditions.Count == 0)
        {
            CustomLogger.Error(this, "Conditions List is empty");
            return;
        }

        _pulseRateConditions.Sort((prc1, prc2) => (int)(prc1.Rate * 100 - prc2.Rate * 100));
        RemoveDuplicate(ref _pulseRateConditions);
    }

    private void RemoveDuplicate(ref List<PulseRateCondition> pulseRateConditions)
    {
        for (int i = pulseRateConditions.Count - 1; i >= 1; i--)
        {
            if (pulseRateConditions[i].Rate == pulseRateConditions[i - 1].Rate)
            {
                pulseRateConditions.Remove(pulseRateConditions[i]);
            }
        }
    }
}
\end{minted}
\subsubsection*{AbstractSpeedChangingComponent.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System;
using UnityEngine;

/// <summary>
/// <para>Enumeration of game speed states.</para>
/// </summary>
[Serializable]
public enum Speed
{
    STOP,
    SLOW,
    NORMAL,
    FAST
}

/// <summary>
/// <para>Abstract class of component that changes its behavior depending on current game speed.</para>
/// </summary>
public abstract class AbstractSpeedChangingComponent : MonoBehaviour
{
    /// <summary>
    /// <para>Change the behavior of this component according to selected <see cref="Speed"/>.</para>
    /// </summary>
    /// <param name="speed">the selected <see cref="Speed"/></param>
    public abstract void ChangeSpeed(Speed speed);

    protected void LogNoSpeedSettingsFor(Speed speed)
    {
        CustomLogger.Error(this, $"No speed settings are specified for speed {Enum.GetName(typeof(Speed), speed)}");
    }
}
\end{minted}
\subsubsection*{ControllerManager.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System;
using UnityEngine;

/// <summary>
/// The Biofeedback control type.
/// </summary>
[Serializable]
public enum BiofeedbackControlType
{
    NONE,
    HEART_RATE
    //,ACCELERATION
}

/// <summary>
/// <para>A class responsible for customizing the player's controllers.</para>
/// </summary>
public sealed class ControllerManager : MonoBehaviour
{
    [Header("Scene settings")] 
    [SerializeField] private PlayerControlType _playerControlType;
    [SerializeField] private BiofeedbackControlType _biofeedbackControlType;
    [SerializeField] private Animator _playerAvatar;

    [Header("Manager components")]
    [SerializeField] private LevelManager _levelManager;
    [SerializeField] private AbstractBiofeedbackManager[] _biofeedbackManagers;
    [SerializeField] private AbstractPlayer[] _availablePlayers;

    private void Start()
    {
        DisableBiofeedbackManagers();
        DisablePlayers();
    }

    private void DisableBiofeedbackManagers()
    {
        foreach (var biofeedbackManager in _biofeedbackManagers)
        {
            if (biofeedbackManager.PulseControl != _biofeedbackControlType)
            {
                biofeedbackManager.gameObject.SetActive(false);
            }
            else
            {
                _levelManager.BiofeedbackManager = biofeedbackManager;
            }
        }
    }

    private void DisablePlayers()
    {
        foreach (var player in _availablePlayers)
        {
            if (player.PlayerControlType != _playerControlType)
            {
                player.gameObject.SetActive(false);
            }
            else
            {
                player.PlayerAvatar.CreatePlayerFromAvatar(_playerAvatar);
            }
        }
    }
}
\end{minted}
\subsubsection*{HpManager.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// <para>Component that controls the amount of player's health.</para>
/// <param name="hpCount">the amount of player's health</param>
/// <param name="hpBar">the <see cref="UIHpBar"/></param>
/// </summary>
public sealed class HpManager : MonoBehaviour
{
    /// <summary>
    /// <para>Action triggered when health points run out.</para>
    /// </summary>
    public event UnityAction OutOfHP;

    /// <summary>
    /// <para>Action triggered when the player's immortality starts.</para>
    /// </summary>
    public event UnityAction StartImmortality;

    /// <summary>
    /// <para>Action triggered when the player's immortality ends.</para>
    /// </summary>
    public event UnityAction StopImmortality;

    [SerializeField] private int _hpCount;
    [Range(0, 10)]
    [SerializeField] private float _immortalityAfterDamageTimeSec = 3f;
    [SerializeField] private UIHpBar _hpBar;

    private int currentHP;
    private float immortalityTime;
    private bool isPlayerImmortal = false;

    /// <summary>
    /// <para>Sets new health point count.</para>
    /// <value>new health point count</value>
    /// </summary>
    public int HpCount
    {
        set
        {
            if (_hpCount != value)
            {
                _hpCount = value;
                currentHP = value;
                _hpBar.CreateNewBar(_hpCount);
            }
            else
            {
                ResetHP();
            }
        }
    }

    private void Update()
    {
        if (immortalityTime <= 0)
        {
            StopPlayerImmortality();
        }
        else
        {
            immortalityTime -= Time.deltaTime;
        }
    }

    /// <summary>
    /// <para>Set all health points to the active state without changing their quantity.</para>
    /// </summary>
    public void ResetHP()
    {
        ChangeHP(_hpCount);
    }

    /// <summary>
    /// <para>Add health point to current.</para>
    /// </summary>
    /// <param name="value">Added value</param>
    public void AddHPToCurrent(int value)
    {
        int newHP = currentHP + value;
        ChangeHP(newHP);
    }

    /// <summary>
    /// <para>Subtract health point from current.</para>
    /// </summary>
    /// <param name="value">Subtracted value</param>
    public void SubtractHPFromCurrent(int value)
    {
        if (immortalityTime > 0)
        {
            return;
        }

        int newHP = currentHP - value;
        StartPlayerImmortality();
        ChangeHP(newHP);
    }

    private void StartPlayerImmortality()
    {
        isPlayerImmortal = true;
        immortalityTime = _immortalityAfterDamageTimeSec;
        StartImmortality?.Invoke();
    }

    private void StopPlayerImmortality()
    {
        if (isPlayerImmortal)
        {
            isPlayerImmortal = false;
            immortalityTime = 0f;
            StopImmortality?.Invoke();
        }
    }

    private void ChangeHP(int newHP)
    {
        if (newHP > _hpCount || newHP < 0)
        {
            return;
        }

        bool activeState = newHP > currentHP;
        while (currentHP != newHP)
        {
            currentHP = activeState ? currentHP : currentHP - 1;
            _hpBar[currentHP] = activeState;
            currentHP = activeState ? currentHP + 1 : currentHP;
        }

        if (currentHP == 0)
        {
            OutOfHP?.Invoke();
            _hpBar.RemoveOldBar();
        }
    }
}
\end{minted}
\subsubsection*{LevelManager.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System.Threading;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// <para>Level manager script that controls events occurring in the level scene.</para>
/// </summary>
public sealed class LevelManager : MonoBehaviour
{
    /// <summary>
    /// <para>Action triggered when the game starts.</para>
    /// </summary>
    public event UnityAction GameStarted;

    /// <summary>
    /// <para>Action triggered when the game ends.</para>
    /// </summary>
    public event UnityAction GameEnded;

    [SerializeField] private HpManager _hpManager;
    [Range(1, 100)] 
    [SerializeField] private int _hpCount;
    [Range(0, 20)]
    [SerializeField] private int _waitBeforeStart = 0;
    [SerializeField] private UISmoothChangeNumberParameterBar _scoreBar;
    [SerializeField] private UINotificationBar _notificationBar;
    [SerializeField] private MultipleButtons _multipleButtons;
    [SerializeField] private AbstractSpeedChangingComponent[] _speedChangingComponents;
    
    private AbstractBiofeedbackManager biofeedbackManager;

    private bool isGameStart = false;
    private CancellationTokenSource timerToken;

    public AbstractBiofeedbackManager BiofeedbackManager
    {
        set
        {
            if (biofeedbackManager != null)
            {
                biofeedbackManager.PulseConditionChange -= ChangeGameSpeedAccordingToPulse;
            }

            biofeedbackManager = value;
            biofeedbackManager.PulseConditionChange += ChangeGameSpeedAccordingToPulse;
        }
    }

    private void Start()
    {
        Cursor.visible = false;
        _scoreBar.SetParameterValue(0);
        _notificationBar.Text = "";
        _hpManager.OutOfHP += EndGame;
        _multipleButtons.ButtonsPressed += StartGame;
        timerToken = new CancellationTokenSource();
        timerToken.Token.Register(() => CustomLogger.Log(this, "Async timer canceled"));
    }

    private void OnDestroy()
    {
        _hpManager.OutOfHP -= EndGame;
        _multipleButtons.ButtonsPressed -= StartGame;
        timerToken.Cancel();
        if (biofeedbackManager != null)
        {
            biofeedbackManager.PulseConditionChange -= ChangeGameSpeedAccordingToPulse;
        }
    }

    /// <summary>
    /// <para>Start game method.</para>
    /// </summary>
    public void StartGame()
    {
        AsyncCountDown.Setup(timerToken.Token)
            .Callback(CountDownBeforeStart)
            .Count(_waitBeforeStart + 1)
            .PeriodBetweenCallback(1, TimeUnit.SECONDS)
            .Start();
    }

    private void CountDownBeforeStart(long count)
    {
        _notificationBar.Text = count.ToString();
        if (count == 0)
        {
            _notificationBar.Text = "";
            StartLevel();
        }
    }

    private void StartLevel()
    {
        _multipleButtons.Hide();
        if (biofeedbackManager?.PulseCondition == PulseCondition.CRITICAL)
        {
            CustomLogger.Log(this, "Critical pulse condition. Request to start the game rejected");
            _multipleButtons.Show();
            return;
        }
        
        CustomLogger.Log(this, "The game has started");
        _hpManager.HpCount = _hpCount;
        _scoreBar.SetParameterValue(0);
        
        GameStarted?.Invoke();
    }

    /// <summary>
    /// <para>End game method.</para>
    /// </summary>
    public void EndGame()
    {
        CustomLogger.Log(this, "The game is over");
        isGameStart = false;
        GameEnded?.Invoke();
        _multipleButtons.Show();
    }

    /// <summary>
    /// <para>Method that takes away selected count of health points from player.</para>
    /// </summary>
    /// <param name="count">Taken away health points count</param>
    public void DrainHealthPoint(int count)
    {
        _hpManager.SubtractHPFromCurrent(count);
    }

    /// <summary>
    /// <para>Method that increases a player's score by selected number of points.</para>
    /// </summary>
    /// <param name="count">Points count added to the player's score</param>
    public void AddScore(int count)
    {
        _scoreBar.AddValue(count);
    }

    /// <summary>
    /// <para>Method that give selected count of health points to player.</para>
    /// </summary>
    /// <param name="count">Given health points count</param>
    public void AddHealthPoint(int count)
    {
        _hpManager.AddHPToCurrent(count);
    }

    /// <summary>
    /// <para>Method that changes game speed according to <see cref="PulseCondition"/>.</para>
    /// </summary>
    /// <param name="pulseCondition"><see cref="PulseCondition"/> depending on which the game speed will be changed</param>
    public void ChangeGameSpeedAccordingToPulse(PulseCondition pulseCondition)
    {
        switch (pulseCondition)
        {
            case PulseCondition.CRITICAL:
                ChangeGameSpeed(Speed.STOP);
                break;
            case PulseCondition.SLOW:
                ChangeGameSpeed(Speed.FAST);
                break;
            case PulseCondition.NORMAL:
                ChangeGameSpeed(Speed.NORMAL);
                break;
            case PulseCondition.FAST:
                ChangeGameSpeed(Speed.SLOW);
                break;
        }
    }

    private void ChangeGameSpeed(Speed newSpeed)
    {
        foreach (AbstractSpeedChangingComponent speedChangingComponent in _speedChangingComponents)
        {
            speedChangingComponent.ChangeSpeed(newSpeed);
        }
    }

#if UNITY_EDITOR

    /// <summary>
    /// <para>Debug method for starting the game from the inspector by pressing the button.</para>
    /// </summary>
    [InspectorButton(Name = "Start game")]
    public void StartGameButton()
    {
        if (!isGameStart)
        {
            isGameStart = true;
            StartGame();
        }
    }

#endif
}
\end{minted}
\subsubsection*{PulseAccelerationManager.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine.Events;

/// <summary>
/// <para>Implementing a <see cref="AbstractBiofeedbackManager"/> through heart rate acceleration.</para>
/// </summary>
public sealed class PulseAccelerationManager : AbstractBiofeedbackManager
{
    /// <summary>
    /// <inheritdoc cref="AbstractBiofeedbackManager.PulseConditionChange"/>
    /// </summary>
    public override event UnityAction<PulseCondition> PulseConditionChange;

    private float acceleration = 80;

    private void Awake()
    {
        //_pulseControl = BiofeedbackControlType.ACCELERATION;
    }

    protected override void OnStart()
    {
        base.OnStart();
        pulseReceiver.AccelerationCalculated += SetAcceleration;
        SetAcceleration(0);
    }

    private void OnDestroy()
    {
        if (pulseReceiver != null)
        {
            pulseReceiver.AccelerationCalculated -= SetAcceleration;
        }
    }

    private void SetAcceleration(float acceleration)
    {
        if (acceleration != this.acceleration)
        {
            this.acceleration = acceleration;
            RecalculateCondition();
            _debugUiBar?.SetParameterValue(this.acceleration);
        }
    }

    private void RecalculateCondition()
    {
        if (_pulseRateConditions.Count == 0)
        {
            CustomLogger.Error(this, "Pulse Rate Conditions List is empty");
            return;
        }

        // TODO Определить как изменять состояние пульса в зависимости от ускарения
        for (int i = 0; i < _pulseRateConditions.Count; i++)
        {
            if (_pulseRateConditions[i].Condition == PulseCondition.NORMAL)
            {
                SetNewPulseConditionFromList(i);
                return;
            }
        }
    }

    private void SetNewPulseConditionFromList(int elementIndex)
    {
        PulseRateCondition selectedPulseAccelerationCondition = _pulseRateConditions[elementIndex];
        PulseCondition newCondition = selectedPulseAccelerationCondition.Condition;
        _debugUiBar?.SetColor(selectedPulseAccelerationCondition.UIBarColor);
        if (pulseCondition != newCondition)
        {
            pulseCondition = newCondition;
            PulseConditionChange?.Invoke(pulseCondition);
        }
    }
}
\end{minted}
\subsubsection*{PulseManager.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine.Events;

/// <summary>
/// <para>Implementing a <see cref="AbstractBiofeedbackManager"/> through heart rate.</para>
/// </summary>
public sealed class PulseManager : AbstractBiofeedbackManager
{
    /// <summary>
    /// <inheritdoc cref="AbstractBiofeedbackManager.PulseConditionChange"/>
    /// </summary>
    public override event UnityAction<PulseCondition> PulseConditionChange;

    private int pulse = 80;

    private void Awake()
    {
        _pulseControl = BiofeedbackControlType.HEART_RATE;
    }

    protected override void OnStart()
    {
        base.OnStart();
        pulseReceiver.PulseReceived += SetPulse;
        SetPulse(0);
    }

    private void OnDestroy()
    {
        if (pulseReceiver != null)
        {
            pulseReceiver.PulseReceived -= SetPulse;
        }
    }

    private void SetPulse(int newPulse)
    {
        if (newPulse != pulse)
        {
            pulse = newPulse;
            RecalculateCondition();
            _debugUiBar?.SetParameterValue(pulse);
        }
    }

    private void RecalculateCondition()
    {
        if (_pulseRateConditions.Count == 0)
        {
            CustomLogger.Error(this, "Pulse Rate Conditions List is empty");
            return;
        }

        for (int i = 0; i < _pulseRateConditions.Count; i++)
        {
            PulseRateCondition currentPulseRateCondition = _pulseRateConditions[i];
            if (pulse < currentPulseRateCondition.Rate)
            {
                SetNewPulseConditionFromList(i);
                return;
            }
        }

        SetNewPulseConditionFromList(_pulseRateConditions.Count - 1);
    }

    private void SetNewPulseConditionFromList(int elementIndex)
    {
        PulseRateCondition selectedPulseRateCondition = _pulseRateConditions[elementIndex];
        PulseCondition newCondition = selectedPulseRateCondition.Condition;
        _debugUiBar?.SetColor(selectedPulseRateCondition.UIBarColor);
        if (pulseCondition != newCondition)
        {
            pulseCondition = newCondition;
            PulseConditionChange?.Invoke(pulseCondition);
        }
    }
}
\end{minted}
\subsubsection*{ObjectMovement.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>A component used to specify the trajectory of an object.</para>
/// </summary>
[ExecuteAlways]
public sealed class ObjectMovement : MonoBehaviour
{
    [SerializeField] private Transform _startPoint;
    [SerializeField] private Transform _endPoint;

    /// <summary>
    /// The starting point of the object movement.
    /// </summary>
    public Transform StartPoint => _startPoint;

    /// <summary>
    /// The ending point of the object movement.
    /// </summary>
    public Transform EndPoint => _endPoint;

    private void Start()
    {
        if (Application.IsPlaying(this))
        {
            DestroyChildren(_startPoint);
            DestroyChildren(_endPoint);
        }
    }

    private void DestroyChildren(Transform parent)
    {
        foreach (Transform child in parent)
        {
            Destroy(child.gameObject);
        }
    }

    private void Update()
    {
        if (_startPoint && _endPoint && !Application.isPlaying)
        {
            Color drawColor = _endPoint.localPosition.z - _startPoint.localPosition.z > 0 ? Color.blue : Color.red;
            _startPoint.localPosition = new Vector3(0, 0, 0);
            _endPoint.localPosition = new Vector3(0, 0, _endPoint.localPosition.z);
            Debug.DrawLine(_startPoint.position, _endPoint.position, drawColor);
        }
    }
}
\end{minted}
\subsubsection*{MultipleButtons.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System.Collections.Generic;
using DG.Tweening;
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// <para>Script that triggers a multiple <see cref="ObjectButton"/> press action.</para>
/// </summary>
public sealed class MultipleButtons : MonoBehaviour
{
    /// <summary>
    /// <para>Simultaneous <see cref="ObjectButton"/> press action.</para>
    /// </summary>
    public event UnityAction ButtonsPressed;

    [SerializeField] private ObjectButton[] _objectButtons;

    private List<ObjectButton> activeStartButtons;
    private bool isButtonsHide = false;
    private float hideDuration = 1;

    private void Start()
    {
        activeStartButtons = new List<ObjectButton>();
        foreach (ObjectButton startButton in _objectButtons)
        {
            startButton.ButtonPressed += ActivateStartButton;
        }
    }

    private void OnDestroy()
    {
        foreach (ObjectButton startButton in _objectButtons)
        {
            startButton.ButtonPressed -= ActivateStartButton;
        }
    }

    private void ActivateStartButton(ObjectButton objectButton)
    {
        if (isButtonsHide || activeStartButtons.Contains(objectButton))
        {
            return;
        }

        activeStartButtons.Add(objectButton);
        objectButton.transform.DOScale(0.7f, 1);

        if (activeStartButtons.Count >= _objectButtons.Length)
        {
            ButtonsPressed?.Invoke();
        }
    }

    /// <summary>
    /// <para>Show buttons if they are hidden.</para>
    /// </summary>
    public void Show()
    {
        if (isButtonsHide)
        {
            transform.DOMoveY(0, hideDuration);
            foreach (ObjectButton startButton in _objectButtons)
            {
                startButton.transform.DOScale(1f, 1);
            }

            isButtonsHide = false;
            activeStartButtons.Clear();
        }
    }

    /// <summary>
    /// <para>Hide buttons if they are not hide.</para>
    /// </summary>
    public void Hide()
    {
        if (!isButtonsHide)
        {
            isButtonsHide = true;
            transform.DOMoveY(-3, hideDuration);
        }

        activeStartButtons.Clear();
    }
}
\end{minted}
\subsubsection*{ObjectButton.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;
using UnityEngine.Events;

/// <summary>
/// <para>Button object component. When a <see cref="PlayerBodypart"/> touches this object, the button press action will be triggered.</para>
/// </summary>
[RequireComponent(typeof(Rigidbody), typeof(Collider))]
public sealed class ObjectButton : MonoBehaviour
{
    /// <summary>
    /// <para>Action triggered when a <see cref="PlayerBodypart"/> touches button object.</para>
    /// </summary>
    public event UnityAction<ObjectButton> ButtonPressed;

    private void OnTriggerEnter(Collider other)
    {
        if (other.TryGetComponent(out PlayerBodypart player))
        {
            ButtonPressed?.Invoke(this);
        }
    }
}
\end{minted}
\subsubsection*{AsyncCountDown.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System;
using System.Threading;
using System.Threading.Tasks;

/// <summary>
/// <para>Time measurement units.</para>
/// </summary>
public enum TimeUnit
{
    DAYS = 86400000,
    HOURS = 3600000,
    MINUTES = 60000,
    SECONDS = 1000,
    MILLISECONDS = 1
}

/// <summary>
/// <para>Class that sets up and starts the async countdown.</para>
/// </summary>
public sealed class AsyncCountDown
{
    private readonly CancellationToken token;
    private TimeUnit type;
    private Action<long> callback;
    private double period;
    private long count;

    /// <summary>
    /// <para>Method for starting the setup.</para>
    /// </summary>
    /// <returns>the AsyncCountDown instance for setup</returns>
    public static AsyncCountDown Setup(CancellationToken token)
    {
        return new AsyncCountDown(token);
    }

    private AsyncCountDown(CancellationToken token)
    {
        this.token = token;
        this.callback = null;
        this.count = 0;
        this.type = TimeUnit.SECONDS;
        this.period = 1;
    }

    private AsyncCountDown self()
    {
        return this;
    }

    /// <param name="callback">the callback to be called when the counter ticks</param>
    /// <returns>self</returns>
    public AsyncCountDown Callback(Action<long> callback)
    {
        this.callback = callback;
        return self();
    }

    /// <param name="count">the number of counter ticks</param>
    /// <returns>self</returns>
    public AsyncCountDown Count(long count)
    {
        this.count = count;
        return self();
    }

    /// <param name="period">the period between counter ticks</param>
    /// <returns>self</returns>
    public AsyncCountDown PeriodBetweenCallback(double period)
    {
        this.period = period;
        return self();
    }

    /// <param name="period">the period between counter ticks</param>
    /// <param name="type">the <see cref="TimeUnit"/></param>
    /// <returns>self</returns>
    public AsyncCountDown PeriodBetweenCallback(double period, TimeUnit type)
    {
        this.period = period;
        this.type = type;
        return self();
    }

    /// <summary>
    /// Starts count down.
    /// </summary>
    public void Start()
    {
        new CountDownExecutor(this);
    }

    private class CountDownExecutor
    {
        private readonly CancellationToken token;
        private readonly Action<long> callback;
        private readonly TimeUnit type;
        private readonly double period;
        private long count;

        /// <summary>
        /// <para>Constructor.</para>
        /// </summary>
        /// <param name="builder">the configured AsyncCountDown class</param>
        public CountDownExecutor(AsyncCountDown builder)
        {
            this.token = builder.token;
            this.callback = builder.callback;
            this.type = builder.type;
            this.period = builder.period;
            this.count = builder.count;

            Tick();
        }

        private void Tick()
        {
            count--;
            callback?.Invoke(count);
            NextTick();
        }

        private async void NextTick()
        {
            if (count > 0)
            {
                double awaitMilliseconds = this.period * (int)this.type;
                await Delay(awaitMilliseconds);
                Tick();
            }
        }

        private async Task Delay(double milliseconds)
        {
            try
            {
                await Task.Delay(TimeSpan.FromMilliseconds(milliseconds), token);
            }
            catch (TaskCanceledException)
            {
            }
        }
    }
}
\end{minted}
\subsubsection*{CustomLogger.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>Class for logging.</para>
/// </summary>
public static class CustomLogger
{
    /// <summary>
    /// Log error message.
    /// </summary>
    /// <param name="obj">the object that sends messages</param>
    /// <param name="message">the message</param>
    public static void Error(Object obj, string message)
    {
        Debug.LogError($"[{obj.name}]: {message}");
    }

    /// <summary>
    /// Log debug message.
    /// </summary>
    /// <param name="obj">the object that sends messages</param>
    /// <param name="message">the message</param>
    public static void Log(Object obj, string message)
    {
        Debug.Log($"[{obj.name}]: {message}");
    }
}
\end{minted}
\subsubsection*{ModifiedPuppetAvatar.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Azure.Kinect.BodyTracking;
using UnityEngine;

[Serializable]
public sealed class BoolVector
{
    public bool X;
    public bool Y;
    public bool Z;
}

[Serializable]
public sealed class FloatVector
{
    public float X;
    public float Y;
    public float Z;
}

/// <summary>
/// <para>Modifications to the avatar position, compared to the tracked body.</para>
/// </summary>
[Serializable]
public sealed class PositionModification
{
    public BoolVector FreezePosition;
    public FloatVector PositionOffset;
    [Header("Debug")] 
    public FloatVector PositionScale;
}


/// <summary>
/// <para>Script used to control an avatar using the Azure Kinect.</para>
/// <remark>This script requires the main camera in the scene. But it must not be a child object of the object using this script</remark>
/// </summary>
public sealed class ModifiedPuppetAvatar : MonoBehaviour
{
    private TrackerHandler kinectDevice;
    private Transform rootPosition;
    private Transform avatarArmatureRoot;
    private PositionModification positionModification;
    private Dictionary<JointId, Quaternion> absoluteOffsetMap;
    private Animator puppetAnimator;
    private Quaternion modelRotation;
    private new GameObject camera;

    /// <summary>
    /// TrackerHandler TrackerHandler located in the Kinect4AzureTrackerAllInOne prefab.
    /// </summary>
    public TrackerHandler KinectDevice
    {
        set => kinectDevice = value;
    }

    /// <summary>
    /// pointBody object which is a child of Kinect4AzureTrackerAllInOne prefab.
    /// </summary>
    public Transform RootPosition
    {
        set => rootPosition = value;
    }

    /// <summary>
    /// The <see cref="PositionModification"/>.
    /// </summary>
    public PositionModification PositionModification
    {
        set => positionModification = value;
    }

    private static HumanBodyBones MapKinectJoint(JointId joint)
    {
        // https://docs.microsoft.com/en-us/azure/Kinect-dk/body-joints
        switch (joint)
        {
            case JointId.Pelvis: return HumanBodyBones.Hips;
            case JointId.SpineNavel: return HumanBodyBones.Spine;
            case JointId.SpineChest: return HumanBodyBones.Chest;
            case JointId.Neck: return HumanBodyBones.Neck;
            case JointId.Head: return HumanBodyBones.Head;
            case JointId.HipLeft: return HumanBodyBones.LeftUpperLeg;
            case JointId.KneeLeft: return HumanBodyBones.LeftLowerLeg;
            case JointId.AnkleLeft: return HumanBodyBones.LeftFoot;
            case JointId.FootLeft: return HumanBodyBones.LeftToes;
            case JointId.HipRight: return HumanBodyBones.RightUpperLeg;
            case JointId.KneeRight: return HumanBodyBones.RightLowerLeg;
            case JointId.AnkleRight: return HumanBodyBones.RightFoot;
            case JointId.FootRight: return HumanBodyBones.RightToes;
            case JointId.ClavicleLeft: return HumanBodyBones.LeftShoulder;
            case JointId.ShoulderLeft: return HumanBodyBones.LeftUpperArm;
            case JointId.ElbowLeft: return HumanBodyBones.LeftLowerArm;
            case JointId.WristLeft: return HumanBodyBones.LeftHand;
            case JointId.ClavicleRight: return HumanBodyBones.RightShoulder;
            case JointId.ShoulderRight: return HumanBodyBones.RightUpperArm;
            case JointId.ElbowRight: return HumanBodyBones.RightLowerArm;
            case JointId.WristRight: return HumanBodyBones.RightHand;
            default: return HumanBodyBones.LastBone;
        }
    }

    /// <summary>
    /// Creates a kinect avatar of the player in the scene.
    /// </summary>
    /// <param name="rootTransform">the avatar armature root</param>
    public void CreateKinectAvatar(Transform rootTransform)
    {
        avatarArmatureRoot = rootTransform;
        modelRotation = transform.rotation;
        camera = GetMainCamera();

        puppetAnimator = transform.GetComponent<Animator>();

        MapBones(avatarArmatureRoot);
    }

    private void MapBones(Transform _rootJointTransform)
    {
        if (_rootJointTransform == null)
        {
            return;
        }

        absoluteOffsetMap = new Dictionary<JointId, Quaternion>();
        for (int i = 0; i < (int)JointId.Count; i++)
        {
            HumanBodyBones hbb = MapKinectJoint((JointId)i);
            if (hbb != HumanBodyBones.LastBone)
            {
                Transform boneTransform = puppetAnimator.GetBoneTransform(hbb);
                Quaternion absOffset = GetSkeletonBone(puppetAnimator, boneTransform.name).rotation;
                // find the absolute offset for the tpose
                while (!ReferenceEquals(boneTransform, _rootJointTransform))
                {
                    boneTransform = boneTransform.parent;
                    absOffset = GetSkeletonBone(puppetAnimator, boneTransform.name).rotation * absOffset;
                }

                absoluteOffsetMap[(JointId)i] = absOffset;
            }
        }
    }

    private GameObject GetMainCamera()
    {
        GameObject foundMainCamera = GameObject.FindGameObjectWithTag("MainCamera");

        Camera[] childCameras = GetComponentsInChildren<Camera>(true);
        foreach (Camera childCamera in childCameras)
        {
            if (childCamera.gameObject == foundMainCamera)
            {
                return null;
            }
        }

        return foundMainCamera;
    }

    private static SkeletonBone GetSkeletonBone(Animator animator, string boneName)
    {
        int count = 0;
        StringBuilder cloneName = new StringBuilder(boneName);
        cloneName.Append("(Clone)");
        foreach (SkeletonBone sb in animator.avatar.humanDescription.skeleton)
        {
            if (sb.name == boneName || sb.name == cloneName.ToString())
            {
                return animator.avatar.humanDescription.skeleton[count];
            }

            count++;
        }

        return new SkeletonBone();
    }

    // Update is called once per frame
    private void LateUpdate()
    {
        for (int j = 0; j < (int)JointId.Count; j++)
        {
            if (MapKinectJoint((JointId)j) != HumanBodyBones.LastBone && absoluteOffsetMap.ContainsKey((JointId)j))
            {
                // get the absolute offset
                Transform finalJoint = puppetAnimator.GetBoneTransform(MapKinectJoint((JointId)j));
                finalJoint.rotation = GetRotationFromDevice(j);
                if (j == 0)
                {
                    finalJoint.position = GetPositionFromDevice(j);
                }
            }
        }

        RotateFullObject();
    }

    private Quaternion GetRotationFromDevice(int j)
    {
        Quaternion absOffset = absoluteOffsetMap[(JointId)j];

        return absOffset * Quaternion.Inverse(absOffset) *
               kinectDevice.absoluteJointRotations[j] * absOffset;
    }

    private Vector3 GetPositionFromDevice(int j)
    {
        Vector3 positionOffset = kinectDevice.absoluteJointPosition[j];
        positionOffset = ApplyConstraints(positionOffset);
        positionOffset = ApplyOffsets(positionOffset);
        positionOffset = AddOffsetToRootPosition(positionOffset);
        positionOffset = ApplyScaleToPosition(positionOffset);

        return avatarArmatureRoot.parent.position + positionOffset;
    }

    private Vector3 ApplyConstraints(Vector3 position)
    {
        return new Vector3(
            positionModification.FreezePosition.X ? 0 : position.x,
            positionModification.FreezePosition.Y ? 0 : position.y,
            positionModification.FreezePosition.Z ? 0 : position.z);
    }

    private Vector3 ApplyOffsets(Vector3 position)
    {
        return new Vector3(
            position.x + positionModification.PositionOffset.X,
            position.y + positionModification.PositionOffset.Y,
            position.z + positionModification.PositionOffset.Z);
    }

    private Vector3 AddOffsetToRootPosition(Vector3 positionOffset)
    {
        Vector3 rootLocalPosition = rootPosition.localPosition;
        return new Vector3(
            rootLocalPosition.x + positionOffset.x,
            rootLocalPosition.y + positionOffset.y,
            rootLocalPosition.z + positionOffset.z);
    }

    private Vector3 ApplyScaleToPosition(Vector3 position)
    {
        return new Vector3(
            position.x * positionModification.PositionScale.X,
            position.y * positionModification.PositionScale.Y,
            position.z * positionModification.PositionScale.Z);
    }

    private void RotateFullObject()
    {
        if (camera != null)
        {
            transform.rotation *= modelRotation;
            transform.rotation *= camera.transform.rotation;
        }
    }
}
\end{minted}
\subsubsection*{PuppetAvatarDeviceConfiguration.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
﻿using UnityEngine;

[RequireComponent(typeof(TrackerHandler))]
public sealed class PuppetAvatarDeviceConfiguration : MonoBehaviour
{
    public BackgroundData m_lastFrameData = new BackgroundData();

    // Handler for SkeletalTracking thread.
    private TrackerHandler trackerHandler;
    private SkeletalTrackingProvider m_skeletalTrackingProvider;

    private void Start()
    {
        //tracker ids needed for when there are two trackers
        const int TRACKER_ID = 0;
        m_skeletalTrackingProvider = new SkeletalTrackingProvider(TRACKER_ID);
        trackerHandler = GetComponent<TrackerHandler>();
    }

    private void Update()
    {
        if (m_skeletalTrackingProvider.IsRunning)
        {
            if (m_skeletalTrackingProvider.GetCurrentFrameData(ref m_lastFrameData))
            {
                if (m_lastFrameData.NumOfBodies != 0)
                {
                    trackerHandler.updateTracker(m_lastFrameData);
                }
            }
        }
    }

    private void OnApplicationQuit()
    {
        if (m_skeletalTrackingProvider != null)
        {
            m_skeletalTrackingProvider.Dispose();
        }
    }
}
\end{minted}
\subsubsection*{SkeletalTrackingProvider.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
﻿using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Runtime.Serialization.Formatters.Binary;
using System.Threading;
using Microsoft.Azure.Kinect.BodyTracking;
using Microsoft.Azure.Kinect.Sensor;
using UnityEngine;

public sealed class SkeletalTrackingProvider : BackgroundDataProvider
{
    private bool readFirstFrame = false;
    private TimeSpan initialTimestamp;
    private Configs configs { get; set; } = new Configs();

    public SkeletalTrackingProvider(int id) : base(id)
    {
        Debug.Log("in the skeleton provider constructor");
    }

    BinaryFormatter binaryFormatter { get; set; } = new BinaryFormatter();

    public Stream RawDataLoggingFile = null;

    protected override void RunBackgroundThreadAsync(int id, CancellationToken token)
    {
        try
        {
            Debug.Log("Starting body tracker background thread.");

            // Buffer allocations.
            BackgroundData currentFrameData = new BackgroundData();
            // Open device.
            using (Device device = Device.Open(id))
            {
                device.StartCameras(new DeviceConfiguration()
                {
                    CameraFPS = FPS.FPS30,
                    ColorResolution = ColorResolution.Off,
                    DepthMode = DepthMode.NFOV_Unbinned,
                    WiredSyncMode = WiredSyncMode.Standalone,
                });

                Debug.Log("Open K4A device successful. id " + id + "sn:" + device.SerialNum);

                var deviceCalibration = device.GetCalibration();

                using (Tracker tracker = Tracker.Create(deviceCalibration, new TrackerConfiguration() { ProcessingMode = TrackerProcessingMode.Gpu, SensorOrientation = SensorOrientation.Default }))
                {
                    Debug.Log("Body tracker created.");
                    while (!token.IsCancellationRequested)
                    {
                        using (Capture sensorCapture = device.GetCapture())
                        {
                            // Queue latest frame from the sensor.
                            tracker.EnqueueCapture(sensorCapture);
                        }

                        // Try getting latest tracker frame.
                        using (Frame frame = tracker.PopResult(TimeSpan.Zero, throwOnTimeout: false))
                        {
                            if (frame == null)
                            {
                                Debug.Log("Pop result from tracker timeout!");
                            }
                            else
                            {
                                IsRunning = true;
                                // Get number of bodies in the current frame.
                                currentFrameData.NumOfBodies = frame.NumberOfBodies;

                                // Copy bodies.
                                for (uint i = 0; i < currentFrameData.NumOfBodies; i++)
                                {
                                    currentFrameData.Bodies[i].CopyFromBodyTrackingSdk(frame.GetBody(i), deviceCalibration);
                                }

                                // Store depth image.
                                Capture bodyFrameCapture = frame.Capture;
                                Image depthImage = bodyFrameCapture.Depth;
                                if (!readFirstFrame)
                                {
                                    readFirstFrame = true;
                                    initialTimestamp = depthImage.DeviceTimestamp;
                                }

                                currentFrameData.TimestampInMs = (float)(depthImage.DeviceTimestamp - initialTimestamp).TotalMilliseconds;
                                currentFrameData.DepthImageWidth = depthImage.WidthPixels;
                                currentFrameData.DepthImageHeight = depthImage.HeightPixels;

                                // Read image data from the SDK.
                                var depthFrame = MemoryMarshal.Cast<byte, ushort>(depthImage.Memory.Span);

                                // Repack data and store image data.
                                int byteCounter = 0;
                                currentFrameData.DepthImageSize = currentFrameData.DepthImageWidth * currentFrameData.DepthImageHeight * 3;

                                for (int it = currentFrameData.DepthImageWidth * currentFrameData.DepthImageHeight - 1; it > 0; it--)
                                {
                                    byte b = (byte)(depthFrame[it] / (configs.SkeletalTracking.MaximumDisplayedDepthInMillimeters) * 255);
                                    currentFrameData.DepthImage[byteCounter++] = b;
                                    currentFrameData.DepthImage[byteCounter++] = b;
                                    currentFrameData.DepthImage[byteCounter++] = b;
                                }

                                if (RawDataLoggingFile != null && RawDataLoggingFile.CanWrite)
                                {
                                    binaryFormatter.Serialize(RawDataLoggingFile, currentFrameData);
                                }

                                // Update data variable that is being read in the UI thread.
                                SetCurrentFrameData(ref currentFrameData);
                            }
                        }
                    }

                    Debug.Log("dispose of tracker now!!!!!");
                    tracker.Dispose();
                }

                device.Dispose();
            }

            if (RawDataLoggingFile != null)
            {
                RawDataLoggingFile.Close();
            }
        }
        catch (Exception e)
        {
            Debug.Log($"catching exception for background thread {e.Message}");
            token.ThrowIfCancellationRequested();
        }
    }
}
\end{minted}
\subsubsection*{TrackerHandler.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
﻿using System.Collections.Generic;
using UnityEngine;
using Microsoft.Azure.Kinect.BodyTracking;

public sealed class TrackerHandler : MonoBehaviour
{
    public Dictionary<JointId, JointId> parentJointMap;
    Dictionary<JointId, Quaternion> basisJointMap;
    public Quaternion[] absoluteJointRotations = new Quaternion[(int)JointId.Count];
    public Vector3[] absoluteJointPosition = new Vector3[(int)JointId.Count];
    public bool drawSkeletons = true;
    Quaternion Y_180_FLIP = new Quaternion(0.0f, 1.0f, 0.0f, 0.0f);

    // Start is called before the first frame update
    private void Awake()
    {
        parentJointMap = new Dictionary<JointId, JointId>();

        // pelvis has no parent so set to count
        parentJointMap[JointId.Pelvis] = JointId.Count;
        parentJointMap[JointId.SpineNavel] = JointId.Pelvis;
        parentJointMap[JointId.SpineChest] = JointId.SpineNavel;
        parentJointMap[JointId.Neck] = JointId.SpineChest;
        parentJointMap[JointId.ClavicleLeft] = JointId.SpineChest;
        parentJointMap[JointId.ShoulderLeft] = JointId.ClavicleLeft;
        parentJointMap[JointId.ElbowLeft] = JointId.ShoulderLeft;
        parentJointMap[JointId.WristLeft] = JointId.ElbowLeft;
        parentJointMap[JointId.HandLeft] = JointId.WristLeft;
        parentJointMap[JointId.HandTipLeft] = JointId.HandLeft;
        parentJointMap[JointId.ThumbLeft] = JointId.HandLeft;
        parentJointMap[JointId.ClavicleRight] = JointId.SpineChest;
        parentJointMap[JointId.ShoulderRight] = JointId.ClavicleRight;
        parentJointMap[JointId.ElbowRight] = JointId.ShoulderRight;
        parentJointMap[JointId.WristRight] = JointId.ElbowRight;
        parentJointMap[JointId.HandRight] = JointId.WristRight;
        parentJointMap[JointId.HandTipRight] = JointId.HandRight;
        parentJointMap[JointId.ThumbRight] = JointId.HandRight;
        parentJointMap[JointId.HipLeft] = JointId.SpineNavel;
        parentJointMap[JointId.KneeLeft] = JointId.HipLeft;
        parentJointMap[JointId.AnkleLeft] = JointId.KneeLeft;
        parentJointMap[JointId.FootLeft] = JointId.AnkleLeft;
        parentJointMap[JointId.HipRight] = JointId.SpineNavel;
        parentJointMap[JointId.KneeRight] = JointId.HipRight;
        parentJointMap[JointId.AnkleRight] = JointId.KneeRight;
        parentJointMap[JointId.FootRight] = JointId.AnkleRight;
        parentJointMap[JointId.Head] = JointId.Pelvis;
        parentJointMap[JointId.Nose] = JointId.Head;
        parentJointMap[JointId.EyeLeft] = JointId.Head;
        parentJointMap[JointId.EarLeft] = JointId.Head;
        parentJointMap[JointId.EyeRight] = JointId.Head;
        parentJointMap[JointId.EarRight] = JointId.Head;

        Vector3 zpositive = Vector3.forward;
        Vector3 xpositive = Vector3.right;
        Vector3 ypositive = Vector3.up;
        // spine and left hip are the same
        Quaternion leftHipBasis = Quaternion.LookRotation(xpositive, -zpositive);
        Quaternion spineHipBasis = Quaternion.LookRotation(xpositive, -zpositive);
        Quaternion rightHipBasis = Quaternion.LookRotation(xpositive, zpositive);
        // arms and thumbs share the same basis
        Quaternion leftArmBasis = Quaternion.LookRotation(ypositive, -zpositive);
        Quaternion rightArmBasis = Quaternion.LookRotation(-ypositive, zpositive);
        Quaternion leftHandBasis = Quaternion.LookRotation(-zpositive, -ypositive);
        Quaternion rightHandBasis = Quaternion.identity;
        Quaternion leftFootBasis = Quaternion.LookRotation(xpositive, ypositive);
        Quaternion rightFootBasis = Quaternion.LookRotation(xpositive, -ypositive);

        basisJointMap = new Dictionary<JointId, Quaternion>();

        // pelvis has no parent so set to count
        basisJointMap[JointId.Pelvis] = spineHipBasis;
        basisJointMap[JointId.SpineNavel] = spineHipBasis;
        basisJointMap[JointId.SpineChest] = spineHipBasis;
        basisJointMap[JointId.Neck] = spineHipBasis;
        basisJointMap[JointId.ClavicleLeft] = leftArmBasis;
        basisJointMap[JointId.ShoulderLeft] = leftArmBasis;
        basisJointMap[JointId.ElbowLeft] = leftArmBasis;
        basisJointMap[JointId.WristLeft] = leftHandBasis;
        basisJointMap[JointId.HandLeft] = leftHandBasis;
        basisJointMap[JointId.HandTipLeft] = leftHandBasis;
        basisJointMap[JointId.ThumbLeft] = leftArmBasis;
        basisJointMap[JointId.ClavicleRight] = rightArmBasis;
        basisJointMap[JointId.ShoulderRight] = rightArmBasis;
        basisJointMap[JointId.ElbowRight] = rightArmBasis;
        basisJointMap[JointId.WristRight] = rightHandBasis;
        basisJointMap[JointId.HandRight] = rightHandBasis;
        basisJointMap[JointId.HandTipRight] = rightHandBasis;
        basisJointMap[JointId.ThumbRight] = rightArmBasis;
        basisJointMap[JointId.HipLeft] = leftHipBasis;
        basisJointMap[JointId.KneeLeft] = leftHipBasis;
        basisJointMap[JointId.AnkleLeft] = leftHipBasis;
        basisJointMap[JointId.FootLeft] = leftFootBasis;
        basisJointMap[JointId.HipRight] = rightHipBasis;
        basisJointMap[JointId.KneeRight] = rightHipBasis;
        basisJointMap[JointId.AnkleRight] = rightHipBasis;
        basisJointMap[JointId.FootRight] = rightFootBasis;
        basisJointMap[JointId.Head] = spineHipBasis;
        basisJointMap[JointId.Nose] = spineHipBasis;
        basisJointMap[JointId.EyeLeft] = spineHipBasis;
        basisJointMap[JointId.EarLeft] = spineHipBasis;
        basisJointMap[JointId.EyeRight] = spineHipBasis;
        basisJointMap[JointId.EarRight] = spineHipBasis;
    }

    public void updateTracker(BackgroundData trackerFrameData)
    {
        //this is an array in case you want to get the n closest bodies
        int closestBody = findClosestTrackedBody(trackerFrameData);

        // render the closest body
        AvatarBody skeleton = trackerFrameData.Bodies[closestBody];
        renderSkeleton(skeleton, 0);
    }

    private int findIndexFromId(BackgroundData frameData, int id)
    {
        int retIndex = -1;
        for (int i = 0; i < (int)frameData.NumOfBodies; i++)
        {
            if ((int)frameData.Bodies[i].Id == id)
            {
                retIndex = i;
                break;
            }
        }

        return retIndex;
    }

    private int findClosestTrackedBody(BackgroundData trackerFrameData)
    {
        int closestBody = -1;
        const float MAX_DISTANCE = 5000.0f;
        float minDistanceFromKinect = MAX_DISTANCE;
        for (int i = 0; i < (int)trackerFrameData.NumOfBodies; i++)
        {
            var pelvisPosition = trackerFrameData.Bodies[i].JointPositions3D[(int)JointId.Pelvis];
            Vector3 pelvisPos = new Vector3((float)pelvisPosition.X, (float)pelvisPosition.Y, (float)pelvisPosition.Z);
            if (pelvisPos.magnitude < minDistanceFromKinect)
            {
                closestBody = i;
                minDistanceFromKinect = pelvisPos.magnitude;
            }
        }

        return closestBody;
    }

    public void turnOnOffSkeletons()
    {
        drawSkeletons = !drawSkeletons;
        const int bodyRenderedNum = 0;
        for (int jointNum = 0; jointNum < (int)JointId.Count; jointNum++)
        {
            transform.GetChild(bodyRenderedNum).GetChild(jointNum).gameObject.GetComponent<MeshRenderer>().enabled = drawSkeletons;
            transform.GetChild(bodyRenderedNum).GetChild(jointNum).GetChild(0).GetComponent<MeshRenderer>().enabled = drawSkeletons;
        }
    }

    public void renderSkeleton(AvatarBody skeleton, int skeletonNumber)
    {
        for (int jointNum = 0; jointNum < (int)JointId.Count; jointNum++)
        {
            Vector3 jointPos = new Vector3(skeleton.JointPositions3D[jointNum].X, -skeleton.JointPositions3D[jointNum].Y, skeleton.JointPositions3D[jointNum].Z);
            absoluteJointPosition[jointNum] = jointPos;
            Vector3 offsetPosition = transform.rotation * jointPos;
            Vector3 positionInTrackerRootSpace = transform.position + offsetPosition;
            Quaternion jointRot = Y_180_FLIP * new Quaternion(skeleton.JointRotations[jointNum].X, skeleton.JointRotations[jointNum].Y,
                skeleton.JointRotations[jointNum].Z, skeleton.JointRotations[jointNum].W) * Quaternion.Inverse(basisJointMap[(JointId)jointNum]);
            absoluteJointRotations[jointNum] = jointRot;
            // these are absolute body space because each joint has the body root for a parent in the scene graph
            transform.GetChild(skeletonNumber).GetChild(jointNum).localPosition = jointPos;
            transform.GetChild(skeletonNumber).GetChild(jointNum).localRotation = jointRot;

            const int boneChildNum = 0;
            if (parentJointMap[(JointId)jointNum] != JointId.Head && parentJointMap[(JointId)jointNum] != JointId.Count)
            {
                Vector3 parentTrackerSpacePosition = new Vector3(skeleton.JointPositions3D[(int)parentJointMap[(JointId)jointNum]].X,
                    -skeleton.JointPositions3D[(int)parentJointMap[(JointId)jointNum]].Y, skeleton.JointPositions3D[(int)parentJointMap[(JointId)jointNum]].Z);
                Vector3 boneDirectionTrackerSpace = jointPos - parentTrackerSpacePosition;
                Vector3 boneDirectionWorldSpace = transform.rotation * boneDirectionTrackerSpace;
                Vector3 boneDirectionLocalSpace = Quaternion.Inverse(transform.GetChild(skeletonNumber).GetChild(jointNum).rotation) * Vector3.Normalize(boneDirectionWorldSpace);
                transform.GetChild(skeletonNumber).GetChild(jointNum).GetChild(boneChildNum).localScale = new Vector3(1, 20.0f * 0.5f * boneDirectionWorldSpace.magnitude, 1);
                transform.GetChild(skeletonNumber).GetChild(jointNum).GetChild(boneChildNum).localRotation = Quaternion.FromToRotation(Vector3.up, boneDirectionLocalSpace);
                transform.GetChild(skeletonNumber).GetChild(jointNum).GetChild(boneChildNum).position = transform.GetChild(skeletonNumber).GetChild(jointNum).position - 0.5f * boneDirectionWorldSpace;
            }
            else
            {
                transform.GetChild(skeletonNumber).GetChild(jointNum).GetChild(boneChildNum).gameObject.SetActive(false);
            }
        }
    }

    public Quaternion GetRelativeJointRotation(JointId jointId)
    {
        JointId parent = parentJointMap[jointId];
        Quaternion parentJointRotationBodySpace = Quaternion.identity;
        if (parent == JointId.Count)
        {
            parentJointRotationBodySpace = Y_180_FLIP;
        }
        else
        {
            parentJointRotationBodySpace = absoluteJointRotations[(int)parent];
        }

        Quaternion jointRotationBodySpace = absoluteJointRotations[(int)jointId];
        Quaternion relativeRotation = Quaternion.Inverse(parentJointRotationBodySpace) * jointRotationBodySpace;

        return relativeRotation;
    }
}
\end{minted}
\subsubsection*{AbstractAvatarSetup.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>Abstract avatar setup class.</para>
/// </summary>
public abstract class AbstractAvatarSetup : MonoBehaviour
{
    /// <summary>
    /// Checks for component errors before performing setup.
    /// </summary>
    /// <returns>true if component contains errors, false if the component can make the setup</returns>
    public virtual bool ComponentContainsErrors()
    {
        return false;
    }

    /// <summary>
    /// Setup spawned avatar.
    /// </summary>
    /// <param name="spawnedAvatar">the avatar that was spawned</param>
    public abstract void SetUp(ref Animator spawnedAvatar);
}
\end{minted}
\subsubsection*{AbstractPlayer.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System;
using UnityEngine;


[Serializable]
public enum PlayerControlType
{
    KEYBOARD,
    KINECT
}

/// <summary>
/// <para>Class of player object.</para>
/// <remarks>Player object must have a <see cref="PlayerAvatar"/> component among its children</remarks>
/// </summary>
public abstract class AbstractPlayer : MonoBehaviour
{
    /// <summary>
    /// The player control type.
    /// </summary>
    public abstract PlayerControlType PlayerControlType { get; }

    private PlayerAvatar playerAvatar;

    /// <summary>
    /// The <see cref="PlayerAvatar"/> component.
    /// </summary>
    public PlayerAvatar PlayerAvatar => playerAvatar;

    private void Awake()
    {
        playerAvatar = GetComponentInChildren<PlayerAvatar>();
    }
}
\end{minted}
\subsubsection*{AvatarColliderSetup.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>Avatar colliders setup.</para>
/// <param name="playerBodypartsColliders">the <see cref="PlayerBodypartsColliders"/> of player</param>
/// </summary>
public class AvatarColliderSetup : AbstractAvatarSetup
{
    [SerializeField] private PlayerBodypartsColliders _playerBodypartsColliders;
    
    private PlayerBodypartsColliders spawnedBodypartsColliders;

    public override bool ComponentContainsErrors()
    {
        if (base.ComponentContainsErrors())
        {
            return true;
        }

        if (_playerBodypartsColliders == null)
        {
            CustomLogger.Error(this, "Humanoid colliders not selected");
            return true;
        }

        return false;
    }

    /// <summary>
    /// Adds colliders to the avatar.
    /// </summary>
    /// <param name="spawnedAvatar"><inheritdoc cref="AbstractAvatarSetup.SetUp"/></param>
    public override void SetUp(ref Animator spawnedAvatar)
    {
        spawnedBodypartsColliders = SpawnColliders();
        MapBodyparts(ref spawnedAvatar);
    }

    private PlayerBodypartsColliders SpawnColliders()
    {
        return Instantiate(_playerBodypartsColliders, transform, false);
    }

    private void MapBodyparts(ref Animator playerAnimator)
    {
        foreach (var playerBodypart in spawnedBodypartsColliders.PlayerBodyparts)
        {
            Transform boneTransform = playerAnimator.GetBoneTransform(playerBodypart.AttachToBone);
            playerBodypart.transform.parent = boneTransform;
            playerBodypart.transform.localPosition = Vector3.zero;
            playerBodypart.transform.localRotation = Quaternion.identity;
            playerBodypart.transform.localScale = Vector3.one;
        }

        Destroy(spawnedBodypartsColliders.gameObject);
    }
}
\end{minted}
\subsubsection*{CustomizablePlayer.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <inheritdoc cref="AbstractPlayer"/>
/// <param name="playerControlType">the player control type</param>
/// </summary>
public sealed class CustomizablePlayer : AbstractPlayer
{
    [SerializeField] private PlayerControlType _playerControlType;
    public override PlayerControlType PlayerControlType => _playerControlType;
}
\end{minted}
\subsubsection*{ImmortalityEffectsSetup.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// <para>Avatar immortality effects setup.</para>
/// <param name="hpManager">the <see cref="HpManager"/></param>
/// <param name="immortalityMaterial">the immortality material</param>
/// <param name="blinkRate">the material blink rate</param>
/// </summary>
public sealed class ImmortalityEffectsSetup : AbstractAvatarSetup
{
    [SerializeField] private HpManager _hpManager;
    [SerializeField] private Material _immortalityMaterial;
    [Range(0.01f, 5)]
    [SerializeField] private float _blinkRate = 0.1f;

    private Dictionary<Renderer, Material> materials = new Dictionary<Renderer, Material>();
    private bool isPlayerImmortal = false;

    private void Start()
    {
        _hpManager.StartImmortality += ChangeMaterialToImmortality;
        _hpManager.StopImmortality += ChangeMaterialToDefault;
    }

    private void OnDestroy()
    {
        _hpManager.StartImmortality -= ChangeMaterialToImmortality;
        _hpManager.StopImmortality -= ChangeMaterialToDefault;
    }

    public override void SetUp(ref Animator spawnedAvatar)
    {
        MaterialsToDictionary(spawnedAvatar, ref materials);
    }

    private void MaterialsToDictionary(Animator spawnedAvatar, ref Dictionary<Renderer, Material> dictionary)
    {
        if (dictionary.Count != 0)
        {
            ChangeMaterialToDefault();
            dictionary.Clear();
        }

        Renderer[] renderers = spawnedAvatar.GetComponentsInChildren<Renderer>();
        foreach (Renderer renderer in renderers)
        {
            dictionary.Add(renderer, renderer.material);
        }
    }

    private void ChangeMaterialToImmortality()
    {
        isPlayerImmortal = true;
        TurnOnImmortalMaterial();
    }

    private void TurnOnImmortalMaterial()
    {
        if (!isPlayerImmortal)
        {
            return;
        }

        foreach (var material in materials)
        {
            material.Key.material = _immortalityMaterial;
        }

        Invoke("ResetMaterial", _blinkRate);
    }

    private void ResetMaterial()
    {
        TurnOnDefaultMaterial();
        Invoke("TurnOnImmortalMaterial", _blinkRate);
    }

    private void ChangeMaterialToDefault()
    {
        isPlayerImmortal = false;
        TurnOnDefaultMaterial();
    }

    private void TurnOnDefaultMaterial()
    {
        foreach (var material in materials)
        {
            material.Key.material = material.Value;
        }
    }
}
\end{minted}
\subsubsection*{KeyboardObjectMovement.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>Script used to move an object using the keyboard.</para>
/// </summary>
public sealed class KeyboardObjectMovement : MonoBehaviour
{
    [SerializeField] private Transform _movedObject;
    [SerializeField] private Transform _leftBorder;
    [SerializeField] private Transform _rightBorder;
    [SerializeField] private Transform _forwardBorder;
    [SerializeField] private Transform _backwardBorder;
    [SerializeField] private float _walkingSpeed = 6f;
    [SerializeField] private float _sitPosition = 0.9f;

    private Vector3 playerVelocity;
    private Vector3 maxPosition;
    private Vector3 minPosition;
    private float startYPosition;
    private float currentYPosition;

    private void Start()
    {
        gameObject.SetActive(_movedObject.gameObject.activeInHierarchy);
        SetXMaxMinPosition();
        SetZMaxMinPosition();
        startYPosition = gameObject.transform.localPosition.y;
        currentYPosition = startYPosition;
    }

    private void SetXMaxMinPosition()
    {
        if (!_leftBorder || !_rightBorder)
        {
            maxPosition.x = float.MaxValue;
            minPosition.x = float.MinValue;
        }
        else
        {
            maxPosition.x = Mathf.Max(_leftBorder.position.x, _rightBorder.position.x);
            minPosition.x = Mathf.Min(_leftBorder.position.x, _rightBorder.position.x);
        }
    }

    private void SetZMaxMinPosition()
    {
        if (!_forwardBorder || !_backwardBorder)
        {
            maxPosition.z = float.MaxValue;
            minPosition.z = float.MinValue;
        }
        else
        {
            maxPosition.z = Mathf.Max(_forwardBorder.position.z, _backwardBorder.position.z);
            minPosition.z = Mathf.Min(_forwardBorder.position.z, _backwardBorder.position.z);
        }
    }

    private void Update()
    {
        MoveLeftRight();
        MoveForwardBackward();
        Sit();
    }

    private void MoveLeftRight()
    {
        float horizontalMove = (-1.0f) * Input.GetAxis("Horizontal");
        float move = horizontalMove * _walkingSpeed * Time.deltaTime;
        Vector3 position = _movedObject.position;
        float newXPosition = Mathf.Clamp(position.x + move, minPosition.x, maxPosition.x);
        Vector3 newPosition = new Vector3(newXPosition, position.y, position.z);
        _movedObject.position = newPosition;
    }

    private void MoveForwardBackward()
    {
        float horizontalMove = (-1.0f) * Input.GetAxis("Vertical");
        float move = horizontalMove * _walkingSpeed * Time.deltaTime;
        Vector3 position = _movedObject.position;
        float newZPosition = Mathf.Clamp(position.z + move, minPosition.z, maxPosition.z);
        Vector3 newPosition = new Vector3(position.x, position.y, newZPosition);
        _movedObject.position = newPosition;
    }

    private void Sit()
    {
        if (Input.GetKey(KeyCode.LeftControl))
        {
            currentYPosition = startYPosition - _sitPosition;
        }
        else
        {
            currentYPosition = startYPosition;
        }

        Vector3 position = _movedObject.position;
        Vector3 newPosition = new Vector3(position.x, currentYPosition, position.z);
        _movedObject.position = newPosition;
    }
}
\end{minted}
\subsubsection*{KeyboardPlayer.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
/// <summary>
/// <para>Class of keyboard player object.</para>
/// </summary>
public sealed class KeyboardPlayer : AbstractPlayer
{
    public override PlayerControlType PlayerControlType => PlayerControlType.KEYBOARD;
}
\end{minted}
\subsubsection*{KinectAvatarSetup.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using Unity.VisualScripting;
using UnityEngine;

/// <summary>
/// <para>Avatar kinect control setup.</para>
/// </summary>
public sealed class KinectAvatarSetup : AbstractAvatarSetup
{
    [Tooltip("TrackerHandler TrackerHandler located in the Kinect4AzureTrackerAllInOne prefab")]
    [SerializeField] private TrackerHandler _kinectDevice;
    [Tooltip("pointBody object which is a child of Kinect4AzureTrackerAllInOne prefab")]
    [SerializeField] private Transform _rootPosition;
    [SerializeField] private PositionModification _positionModification;
    
    public override bool ComponentContainsErrors()
    {
        if (base.ComponentContainsErrors())
        {
            return true;
        }

        if (_kinectDevice == null)
        {
            CustomLogger.Error(this, "No kinect device");
            return true;
        }

        return false;
    }

    /// <summary>
    /// Adds kinect control to the avatar.
    /// </summary>
    /// <param name="spawnedAvatar"><inheritdoc cref="AbstractAvatarSetup.SetUp"/></param>
    public override void SetUp(ref Animator spawnedAvatar)
    {
        ModifiedPuppetAvatar puppetAvatar = spawnedAvatar.AddComponent<ModifiedPuppetAvatar>();
        puppetAvatar.KinectDevice = _kinectDevice;
        puppetAvatar.RootPosition = _rootPosition;
        puppetAvatar.PositionModification = _positionModification;
        // RPM Avatar fix
        Transform armatureRoot = RPMAvatarCorrectionArmatureRoot(spawnedAvatar, puppetAvatar);

        puppetAvatar.CreateKinectAvatar(armatureRoot);
    }

    // RPM avatars have a special skeletal structure.
    // In RPM avatars, the root of the Hips skeleton is packed into an Armature object,
    // which should be considered the root of the avatar skeleton
    private Transform RPMAvatarCorrectionArmatureRoot(Animator spawnedPlayer, ModifiedPuppetAvatar puppetAvatar)
    {
        Transform armatureRoot = spawnedPlayer.GetBoneTransform(HumanBodyBones.Hips);
        if (armatureRoot.parent != puppetAvatar.transform)
        {
            return armatureRoot.parent;
        }

        return armatureRoot;
    }
}
\end{minted}
\subsubsection*{KinectPlayer.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
/// <summary>
/// <para>Class of kinect player object.</para>
/// </summary>
public sealed class KinectPlayer : AbstractPlayer
{
    public override PlayerControlType PlayerControlType => PlayerControlType.KINECT;
}
\end{minted}
\subsubsection*{PlayerAvatar.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>Class that creates the player avatar in the scene.</para>
/// <param name="avatarSetups">the list of <see cref="AbstractAvatarSetup"/></param>
/// </summary>
public class PlayerAvatar : MonoBehaviour
{
    [SerializeField] private AbstractAvatarSetup[] _avatarSetups;

    /// <summary>
    /// The player avatar Animator spawned in the scene.
    /// </summary>
    protected Animator spawnedPlayer;

    private bool isPlayerSpawned;

    private void Awake()
    {
        isPlayerSpawned = false;
    }

    /// <summary>
    /// Creates a player avatar from the specified player's prefab animator.
    /// </summary>
    /// <param name="avatarPrefab">the specified player's prefab animator</param>
    public void CreatePlayerFromAvatar(Animator avatarPrefab)
    {
        if (DoesComponentContainErrors())
        {
            return;
        }

        if (!avatarPrefab.avatar.isHuman)
        {
            CustomLogger.Error(this, "The avatar's skeleton is not humanoid");
            return;
        }

        spawnedPlayer = SpawnPlayer(avatarPrefab);
        AvatarSetup(ref spawnedPlayer);
        isPlayerSpawned = true;
    }

    protected virtual bool DoesComponentContainErrors()
    {
        if (isPlayerSpawned)
        {
            return true;
        }

        foreach (var avatarSetup in _avatarSetups)
        {
            if (avatarSetup.ComponentContainsErrors())
            {
                return true;
            }
        }

        return false;
    }

    private Animator SpawnPlayer(Animator avatarPrefab)
    {
        return Instantiate(avatarPrefab, transform, false);
    }

    private void AvatarSetup(ref Animator playerAnimator)
    {
        foreach (var avatarSetup in _avatarSetups)
        {
            avatarSetup.SetUp(ref playerAnimator);
        }
    }

    /// <summary>
    /// Destroy a player avatar.
    /// </summary>
    public void DestroyPlayerAvatar()
    {
        if (spawnedPlayer != null)
        {
            Destroy(spawnedPlayer.gameObject);
        }
    }
}
\end{minted}
\subsubsection*{PlayerBodypart.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>Component used to define a player's body part.</para>
/// </summary>
public sealed class PlayerBodypart : MonoBehaviour
{
    [SerializeField] private HumanBodyBones _attachToBone;

    public HumanBodyBones AttachToBone => _attachToBone;
}
\end{minted}
\subsubsection*{PlayerBodypartsColliders.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>Class storing colliders of player's bodyparts.</para>
/// </summary>
public sealed class PlayerBodypartsColliders : MonoBehaviour
{
    [SerializeField] private PlayerBodypart[] _playerBodyparts;

    /// <summary>
    /// The list of player bodyparts.
    /// </summary>
    public PlayerBodypart[] PlayerBodyparts => _playerBodyparts;
}
\end{minted}
\subsubsection*{UIHealthPoint.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// <para>Script for displaying one health point in UI.</para>
/// </summary>
public sealed class UIHealthPoint : MonoBehaviour
{
    [SerializeField] private Image _activeHeart;
    [SerializeField] private Image _notActiveHeart;
    [SerializeField] private bool _isActive;

    /// <summary>
    /// Sets active state for health point.
    /// </summary>
    /// <value>Is health point active</value>
    public bool IsActive
    {
        set
        {
            _isActive = value;
            _activeHeart.gameObject.SetActive(_isActive);
            _notActiveHeart.gameObject.SetActive(!_isActive);
        }
    }

    private void Start()
    {
        _activeHeart.gameObject.SetActive(_isActive);
        _notActiveHeart.gameObject.SetActive(!_isActive);
    }
}
\end{minted}
\subsubsection*{UIHpBar.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;

/// <summary>
/// <para>Script for displaying health bar in UI. Health bar consists of health points - UIHealthPoint.</para>
/// <param name="uiHealthPointPrefab">the <see cref="UIHealthPoint"/> prefab</param>
/// <param name="prefabSpacing">the spacing between spawn prefabs</param>
/// </summary>
public sealed class UIHpBar : MonoBehaviour
{
    [SerializeField] private UIHealthPoint _uiHealthPointPrefab;
    [Range(0, 100)] 
    [SerializeField] private float _prefabSpacing;

    private UIHealthPoint[] hpImagesArray;

    private float hpImageWidth;
    private float hpImageHeight;

    /// <summary>
    /// Sets the active status for health points.
    /// </summary>
    /// <param name="index">the index of health point</param>
    public bool this[int index]
    {
        set
        {
            if (index < 0 && index >= hpImagesArray.Length)
            {
                CustomLogger.Error(this, "Attempting to change the active status of a non-existing health point array index.");
                return;
            }

            hpImagesArray[index].IsActive = value;
        }
    }

    /// <summary>
    /// <para>Removes the old hp bar.</para>
    /// </summary>
    public void RemoveOldBar()
    {
        if (hpImagesArray != null)
        {
            for (int i = hpImagesArray.Length - 1; i >= 0; i--)
            {
                Destroy(hpImagesArray[i].gameObject);
            }

            hpImagesArray = null;
        }
    }

    /// <summary>
    /// <para>Creates a new hp bar with the specified amount of hp.</para>
    /// </summary>
    /// <param name="hpCount">the specified amount of hp</param>
    public void CreateNewBar(int hpCount)
    {
        if (hpImagesArray != null)
        {
            RemoveOldBar();
        }

        hpImagesArray = new UIHealthPoint[hpCount];
        Transform prefabTransform = _uiHealthPointPrefab.transform;
        Rect imageRectTransform = ((RectTransform)prefabTransform).rect;
        hpImageWidth = imageRectTransform.width * prefabTransform.localScale.x;
        hpImageHeight = imageRectTransform.height * prefabTransform.localScale.y;
        for (int i = 0; i < hpImagesArray.Length; i++)
        {
            var spawnedHeart = SpawnHeart(i);
            hpImagesArray[i] = spawnedHeart;
            spawnedHeart.IsActive = true;
        }
    }

    private UIHealthPoint SpawnHeart(int xOffset)
    {
        float fullXOffset = -xOffset * hpImageWidth - _prefabSpacing - hpImageWidth / 2;
        float fullYOffset = -hpImageHeight / 2;
        Vector3 spawnPosition = transform.position + new Vector3(fullXOffset, fullYOffset);

        UIHealthPoint spawnedUIHealthPoint =
            Instantiate(_uiHealthPointPrefab.gameObject, spawnPosition, Quaternion.identity)
                .GetComponent<UIHealthPoint>();
        spawnedUIHealthPoint.transform.SetParent(transform);

        return spawnedUIHealthPoint;
    }
}
\end{minted}
\subsubsection*{UINotificationBar.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using UnityEngine;
using TMPro;

/// <summary>
/// TODO: XML-Doc
/// <para>Class description</para>
/// </summary>
public sealed class UINotificationBar : MonoBehaviour
{
    [SerializeField] private TMP_Text _text;

    public string Text
    {
        get => _text.text;
        set => _text.text = value;
    }
}
\end{minted}
\subsubsection*{UINumberParameterBar.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System;
using TMPro;
using UnityEngine;

/// <summary>
/// <para>Class displays the value of a numeric parameter on the UI.</para>
/// Display format: "Parameter name: Value"
/// </summary>
public class UINumberParameterBar : MonoBehaviour
{
    [SerializeField] private TMP_Text _text;
    [SerializeField] private string _parameterName;
    [Range(0, 6)]
    [SerializeField] private int _decimalPoint;

    [SerializeField] private bool _barVisibility;

    /// <summary>
    /// <para>Parameter value displayed in UI each frame.</para>
    /// </summary>
    protected float parameterValue = 0;

    private void Update()
    {
        OnUpdate();
    }

    protected virtual void OnUpdate()
    {
        if (_barVisibility)
        {
            _text.text = _parameterName + ": " + Math.Round(parameterValue, _decimalPoint);
        }
        else
        {
            _text.text = "";
        }
    }

    /// <summary>
    /// <para>Sets bar visibility.</para>
    /// </summary>
    /// <param name="visible">Is bar visible</param>
    public void SetVisible(bool visible)
    {
        _barVisibility = visible;
    }

    /// <summary>
    /// <para>Sets showed parameter name.</para>
    /// </summary>
    /// <param name="parameterName">The parameter name</param>
    public void SetParameterName(string parameterName)
    {
        _parameterName = parameterName;
    }

    /// <summary>
    /// <para>Sets showed parameter value.</para>
    /// </summary>
    /// <param name="parameterValue">The parameter value</param>
    public virtual void SetParameterValue(float parameterValue)
    {
        this.parameterValue = parameterValue;
    }

    /// <summary>
    /// <para>Sets the color of the bar text.</para>
    /// </summary>
    /// <param name="newColor">The new text color</param>
    public void SetColor(Color newColor)
    {
        _text.color = newColor;
    }
}
\end{minted}
\subsubsection*{UISmoothChangeNumberParameterBar.cs}
\begin{minted}[fontsize=\tiny, breaklines, breakafter=d]{csharp}
using System;
using UnityEngine;

/// <summary>
/// <para>
///<inheritdoc cref="UINumberParameterBar"/>
/// If the value of a parameter has changed, the value on the UI will change from the previous value to the new value at the selected speed
/// </para>
/// </summary>
public sealed class UISmoothChangeNumberParameterBar : UINumberParameterBar
{
    [Range(1, 1000)]
    [SerializeField] private int _changeParameterSpeed = 10;

    private float currentValue = 0;
    private float parameterSum;

    protected override void OnUpdate()
    {
        if (Math.Abs(currentValue - parameterValue) > 0)
        {
            parameterSum += Time.deltaTime * (currentValue - parameterValue) * _changeParameterSpeed;
            parameterValue = parameterSum;
        }

        base.OnUpdate();
    }

    /// <summary>
    /// <inheritdoc cref="UINumberParameterBar.SetParameterValue"/>
    /// </summary>
    /// <param name="parameterValue"><inheritdoc cref="UINumberParameterBar.SetParameterValue"/></param>
    public override void SetParameterValue(float parameterValue)
    {
        currentValue = parameterValue;
    }

    /// <summary>
    /// <para>Add number value current. If you want to subtract from the current value just add a negative number.</para>
    /// </summary>
    /// <param name="addedValue">The added number value</param>
    public void AddValue(float addedValue)
    {
        parameterSum = parameterValue;
        currentValue += addedValue;
    }
}
\end{minted}
